%!PS

% Barcode Writer in Pure PostScript - Version 2020-12-09
% https://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2019 Terry Burton
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.


/lintnumeric {
    true exch {
        dup 48 lt exch 57 gt or { pop false exit } if
    } forall
    not { pop (Not numeric) false exit } if
} bind def

/lintcset82 {
    true exch {
        1 string dup 0 4 -1 roll put
        (!"%&'()*+,-./0123456789:;<=>?ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz)
        exch search not { pop pop false exit } if
        pop pop pop
    } forall
    not { pop (Not numeric) false exit } if
} bind def

/lintgs1ii {
    (-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz)
    exch search not {pop pop (Invalid importer index) false exit} if
    pop pop pop
} bind def

/lintcsum {
    mark exch
    dup length 2 mod 0 eq {3} {1} ifelse
    exch { 48 sub 1 index mul exch 4 exch sub } forall pop
    0 counttomark 1 sub {add} repeat exch pop
    10 mod 0 ne { pop (Bad checksum) false exit } if
} bind def

/lintiban {
    dup length 4 lt { pop pop (IBAN too short) false exit } if
    mark exch mark exch {} forall counttomark -4 roll counttomark array astore exch pop {
        48 sub dup 9 gt {7 sub dup 10 idiv exch 10 mod} if
    } forall counttomark array astore exch pop
    0 exch {exch 10 mul add 97 mod} forall
    1 ne { pop (IBAN checksum incorrect) false exit } if
} bind def

/lintnonzero {
    false exch { 48 ne {pop true} if } forall
    not { pop (Zero not permitted) false exit } if
} bind def

/lintyymmd0 {
    dup 2 2 getinterval cvi dup 1 lt exch 12 gt or { pop (Invalid month) false exit } if
    dup 0 2 getinterval cvi dup  21  sub  % Update 20YY periodically for century calculation
    dup 51 ge {pop 1900 add} { -50 le {2100 add} {2000 add} ifelse} ifelse  % YYYY
    dup 400 mod 0 eq exch dup 4 mod 0 eq exch 100 mod 0 ne and or           % Leap year?
    [ 31  3 -1 roll {29} {28} ifelse  31 30 31 30 31 31 30 31 30 31 ]
    1 index 2 2 getinterval cvi 1 sub get
    exch 4 2 getinterval cvi lt { pop (Invalid day of month) false exit } if
} bind def

/lintyymmdd {
    dup 4 2 getinterval cvi 1 lt { pop (Invalid day of month) false exit } if
    lintyymmd0
} bind def

/linthhmm {
    dup 0 2 getinterval cvi 23 gt { pop pop (Invalid hour of day) false exit } if
    2 2 getinterval cvi 59 gt { pop (Invalid minute in the hour) false exit } if
} bind def

/linthhoptmmss {
    dup length dup 2 ne exch dup 4 ne exch 6 ne and and {
        pop (Invalid length for time of day with optional mins and secs) false exit
    } if
    dup 0 2 getinterval cvi 23 gt { pop pop (Invalid hour of day) false exit } if
    dup length 4 ge {
        dup 2 2 getinterval cvi 59 gt { pop pop (Invalid minute in the hour) false exit } if
    } if
    dup length 6 eq {
        4 2 getinterval cvi 59 gt { pop (Invalid second in the minute) false exit } if
    } if
} bind def

/lintwinding {
    dup (0) ne exch dup (1) ne exch (9) ne and and {
        pop (Invalid winding direction) false exit
    } if
} bind def

/lintpieceoftotal {
    dup length 2 mod 0 ne { pop pop (Invalid piece/total length) false exit } if
    dup dup length 2 idiv 0 exch getinterval cvi
    dup 0 eq { pop pop pop (Invalid piece number) false exit } if
    exch dup length 2 idiv dup getinterval cvi
    dup 0 eq { pop pop pop (Invalid total number) false exit } if
    gt { pop (Piece number exceeds total) false exit } if
} bind def

/lintnacc {  % TODO
    pop
} bind def

/lintnapo {  % TODO
    pop
} bind def

/isocc << [
    /004 /008 /010 /012 /016 /020 /024 /028 /031 /032 /036 /040 /044 /048
    /050 /051 /052 /056 /060 /064 /068 /070 /072 /074 /076 /084 /086 /090 /092 /096
    /100 /104 /108 /112 /116 /120 /124 /132 /136 /140 /144 /148
    /152 /156 /158 /162 /166 /170 /174 /175 /178 /180 /184 /188 /191 /192 /196
    /203 /204 /208 /212 /214 /218 /222 /226 /231 /232 /233 /234 /238 /239 /242 /246 /248
    /250 /254 /258 /260 /262 /266 /268 /270 /275 /276 /288 /292 /296
    /300 /304 /308 /312 /316 /320 /324 /328 /332 /334 /336 /340 /344 /348
    /352 /356 /360 /364 /368 /372 /376 /380 /384 /388 /392 /398
    /400 /404 /408 /410 /414 /417 /418 /422 /426 /428 /430 /434 /438 /440 /442 /446
    /450 /454 /458 /462 /466 /470 /474 /478 /480 /484 /492 /496 /498 /499
    /500 /504 /508 /512 /516 /520 /524 /528 /531 /533 /534 /535 /540 /548
    /554 /558 /562 /566 /570 /574 /578 /580 /581 /583 /584 /585 /586 /591 /598
    /600 /604 /608 /612 /616 /620 /624 /626 /630 /634 /638 /642 /643 /646
    /652 /654 /659 /660 /662 /663 /666 /670 /674 /678 /682 /686 /688 /690 /694
    /702 /703 /704 /705 /706 /710 /716 /724 /728 /729 /732 /740 /744 /748
    /752 /756 /760 /762 /764 /768 /772 /776 /780 /784 /788 /792 /795 /796 /798
    /800 /804 /807 /818 /826 /831 /832 /833 /834 /840
    /850 /854 /858 /860 /862 /876 /882 /887 /894
] {dup} forall >> def

/lintisocc {
    isocc exch known not { pop (Unknown country code) false exit } if
} bind def

/lintmisocc {
    dup length 3 mod 0 ne {
        pop pop (Not a group of three-digit country codes) false exit
    } if
    true
    0 3 3 index length 1 sub {
        2 index exch 3 getinterval
        isocc exch known not { pop pop false exit } if
    } for
    not { pop (Unknown country code) false exit } if
    pop pop
} bind def

% Test linter functions with:
%true 1 { (DE91100001000123456789) lintiban } repeat

% TODO Generate from the spec file
/gs1syntax <<

    (00) <<
         /cset  /N
         /min   18
         /max   18
         /check [ //lintcsum ]
     >>

     (01) <<
         /cset  /N
         /min   14
         /max   14
         /check [ //lintcsum ]
     >>

     (10) <<
         /cset  /X
         /min   1
         /max   20
         /check []
     >>

>> def


%%BeginResource: Category uk.co.terryburton.bwipp 0.0 2020120900 29629 32838
%%BeginData:          6 ASCII Lines
currentglobal
true setglobal
/Generic /Category findresource dup length 1 add dict copy dup
/InstanceType /setpacking where {pop /packedarraytype} {/arraytype} ifelse put
/uk.co.terryburton.bwipp exch /Category defineresource pop
setglobal
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp raiseerror 0.0 2020120900 39041 38872
%%BeginData:         15 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/raiseerror {
  $error exch /errorinfo exch put
  $error exch /errorname exch put
  $error /command null put
  $error /newerror true put
  stop
}
[/barcode] {null def} forall
bind def
/raiseerror dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp parseinput 0.0 2020120900 58537 58180
%%BeginData:        129 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
4 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/parseinput {

    6 dict begin

    /fncvals exch def
    /barcode exch def

    /parse     dup dup fncvals exch get def fncvals exch undef
    /parsefnc  dup dup fncvals exch get def fncvals exch undef
    /parseonly dup dup fncvals exch known def fncvals exch undef
    /eci       dup dup fncvals exch known def fncvals exch undef

    /msg barcode length array def
    /j 0 def
    barcode {  % loop
        (^) search exch
        % Copy characters up to a "^"
        dup length exch
        msg exch j exch [ exch {} forall ] putinterval
        j add /j exch def
        {  % Found a "^" escape character
            pop
            1 {  % common exit

                parse not parsefnc not and {  % "^" as is
                    msg j 94 put
                    /j j 1 add def
                    exit
                } if

                % Encode "^" to start with
                msg j 94 put
                /j j 1 add def

                % parse
                parse {
                    dup length 3 ge {
                        dup 0 3 getinterval true exch {
                            dup 48 lt exch 57 gt or { pop false } if
                        } forall
                        {  % "^NNN" to byte
                            dup 0 3 getinterval cvi dup 255 gt {
                                pop pop
                                /bwipp.invalidOrdinal (Ordinal must be 000 to 255) //raiseerror exec
                            } if
                            /j j 1 sub def  % Replace "^" with ordinal
                            msg exch j exch put
                            /j j 1 add def
                            dup length 3 sub 3 exch getinterval
                        } if
                    } if
                } if

                parseonly
                parsefnc not or
                msg j 1 sub get 94 ne  % Carat was substituted away
                or {exit} if

                % parsefnc
                /j j 1 sub def
                dup length 3 lt {
                    pop
                    /bwipp.truncatedFNC (Function character truncated) //raiseerror exec
                } if
                dup 0 get 94 eq {  % "^^" -> "^"
                    msg j 94 put
                    /j j 1 add def
                    dup length 1 sub 1 exch getinterval
                    exit
                } if
                dup 0 3 getinterval (ECI) eq eci and {  % "^ECInnnnnn" -> -1nnnnnn
                    dup length 9 lt {
                        pop
                        /bwipp.truncatedECI (ECI truncated) //raiseerror exec
                    } if
                    dup 3 6 getinterval
                    dup {
                        dup 48 lt exch 57 gt or {
                            pop pop
                            /bwipp.invalidECI (ECI must be 000000 to 999999) //raiseerror exec
                        } if
                    } forall
                    0 exch {48 sub sub 10 mul} forall 10 idiv 1000000 sub
                    msg exch j exch put
                    /j j 1 add def
                    dup length 9 sub 9 exch getinterval
                    exit
                } if
                dup length 4 lt {  % "^FNCx" -> fncvals{FNCx}
                    pop
                    /bwipp.truncatedFNC (Function character truncated) //raiseerror exec
                } if
                dup 0 4 getinterval dup fncvals exch known not {
                    dup length 28 add string dup 28 4 -1 roll putinterval
                    dup 0 (Unknown function character: ) putinterval
                    exch pop
                    /bwipp.unknownFNC exch //raiseerror exec
                } if
                fncvals exch get
                msg exch j exch put
                /j j 1 add def
                dup length 4 sub 4 exch getinterval
                exit

            } repeat
        } {  % No more "^" characters
            exit
        }  ifelse
    } loop

    parseonly not {
        msg 0 j getinterval
    } {
        j string
        0 1 j 1 sub { 1 index exch dup msg exch get put } for
    } ifelse

    end

}
[/barcode] {null def} forall
bind def
/parseinput dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp gs1lint 0.0 2020120900 38988 38799
%%BeginData:         21 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/gs1lint {

    20 dict begin

    /vals exch def
    /ais exch def

    true
    0 1 vals length 1 sub {
        dup ais exch get /ai exch def
        vals exch get /val exch def
        gs1syntax ai known {
% TODO for each element reading maximal prefix of val
            /props gs1syntax ai get def
            val length props /min get lt {
                pop (Too short) false exit
            } if
            val length props /max get gt {
                pop (Too long) false exit
            } if
            << /N //lintnumeric  /X //lintcset82 >> props /cset get get val exch exec
            val length 0 gt {
                props /check get { val exch exec } forall
            } if
        } if
    } for
    not {
        dup length ai length add 7 add string
        dup 0 (AI \() putinterval
        dup 4 ai putinterval
        dup 4 ai length add (\): ) putinterval
        dup 7 ai length add 4 -1 roll putinterval
        /bwipp.gs1Linter exch //raiseerror exec
    } if

    end

}
[/barcode] {null def} forall
bind def
/gs1lint dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp renmatrix 0.0 2020120900 90671 89701
%%BeginData:        306 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
begin
/renmatrix {

    20 dict begin

    /args exch def

    % Default options
    /width 1 def
    /height 1 def
    /barcolor (unset) def
    /backgroundcolor (unset) def
    /colormap (unset) def
    /dotty false def
    /inkspread 0 def
    /inkspreadh 0 def
    /inkspreadv 0 def
    /includetext false def
    /txt [] def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 0 def
    /textgaps 0 def
    /alttext () def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /width width cvr def
    /height height cvr def
    /barcolor barcolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /inkspreadh inkspreadh cvr def
    /inkspreadv inkspreadv cvr def
    /textcolor textcolor cvlit def
    /textxalign textxalign cvlit def
    /textyalign textyalign cvlit def
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /textgaps textgaps cvr def
    /alttext alttext cvlit def

    inkspread 0 ne {/inkspreadh inkspread def} if
    inkspread 0 ne {/inkspreadv inkspread def} if

    /xyget { pixx mul add pixs exch get} bind def
    /cget { pixx mul add cache exch get and} bind def
    /cput {  % Optimise by only storing "stem" corners
        dup 4 mod 0 eq { % dir is up or left
            3 1 roll pixx mul add cache exch 2 copy get 4 -1 roll or put
        } {
            pop pop pop
        } ifelse
    } bind def

    /abcd {
        4 string 0 [
            5 -2 roll
            pixx mul add dup
            pixs exch 2 getinterval aload pop 3 -1 roll  % A B
            pixs exch pixx add 2 getinterval aload pop   % C D
        ] {3 copy 48 add put pop 1 add} forall pop
    } bind def

    /right {dir 1 ne {x y dir cput [x y]} if  /x x 1 add def  /dir 1 def} bind def
    /down  {dir 2 ne {x y dir cput [x y]} if  /y y 1 add def  /dir 2 def} bind def
    /left  {dir 4 ne {x y dir cput [x y]} if  /x x 1 sub def  /dir 4 def} bind def
    /up    {dir 8 ne {x y dir cput [x y]} if  /y y 1 sub def  /dir 8 def} bind def

    /trace {
        % Walk the outline of a region emitting edge coordinates of the path
        /y exch def  /x exch def
        % dir 1:right 2:down 4:left 8:up
        /dir x 1 add y 1 add xyget 1 eq {8} {4} ifelse def
        /sx x def  /sy y def  /sdir dir def

        % A B
        % C D
        mark {
            x y abcd
            1 {  % Common exit
                dup dup (0001) eq exch dup (0011) eq exch (1011) eq or or {pop right exit} if
                dup dup (0010) eq exch dup (1010) eq exch (1110) eq or or {pop down  exit} if
                dup dup (1000) eq exch dup (1100) eq exch (1101) eq or or {pop left  exit} if
                dup dup (0100) eq exch dup (0101) eq exch (0111) eq or or {pop up    exit} if
                dup (1001) eq {
                    dir 2 eq {pop left exit} {pop right exit} ifelse
                } {  % 0110
                    dir 1 eq {pop down exit} {pop up exit} ifelse
                } ifelse
            } repeat
            x sx eq y sy eq and dir sdir eq and {exit} if
        } loop
        counttomark array astore exch pop

    } bind def

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Plot a layer of single colour
    /drawlayer {

        /pixsorig pixs def
        /pixs exch def

        % Pad the bitmap on all sides
        /pixs [
            pixx 2 add {0} repeat
            0 pixx pixs length 1 sub {
                0 exch
                pixs exch pixx getinterval aload pop
                0
            } for
            pixx 2 add {0} repeat
        ] def
        /pixx pixx 2 add def
        /pixy pixy 2 add def

        % Cache of visited corners for each direction
        /cache [ pixs length {0} repeat ] def

        % Construct paths by tracing regions avoiding duplication by using the cache
        /paths [
            0 1 pixy 2 sub {
                /j exch def
                0 1 pixx 2 sub {
                    /i exch def
                    /k i j abcd def
                    k (0001) eq k (1001) eq or {  % Black region stem corners
                        8 i j cget 0 eq {
                            i j trace
                        } if
                    } if
                    k (1110) eq {  % White region stem corner
                        4 i j cget 0 eq {
                            i j trace
                        } if
                    } if
                } for
            } for
        ] def

        % Revert the bitmap size
        /pixx pixx 2 sub def
        /pixy pixy 2 sub def

        % Draw the image
        newpath
        paths {
            /p exch def
            /len p length def
            p len 1 sub get aload pop
            p 0 get aload pop
            0 1 len 1 sub {                                % x1 y1 x2 y2
                /i exch def
                p i 1 add len mod get aload pop 6 -2 roll  % x3 y3 x1 y1 x2 y2
                5 index inkspreadh
                4 index 4 -1 roll lt {add} {sub} ifelse    % y3<y1 ? x2+i : x2-i
                4 1 roll
                4 index inkspreadv
                4 index 4 -1 roll gt {add} {sub} ifelse    % x3>x1 ? y2+i : y2-i
                4 -1 roll exch pixy exch sub
                i 0 eq {moveto} {lineto} ifelse
            } for                                          % x2 y2 x3 y3
            closepath
            pop pop pop pop
        } forall
        fill

        /pixs pixsorig def

    } bind def

    /drawlayerdots {

        /pixsorig pixs def
        /pixs exch def

        newpath
        0 1 pixs length 1 sub {
            dup pixx mod /x exch def
            pixx idiv /y exch def
            x y xyget 1 eq {
               x 0.5 add pixy y sub 0.5 sub moveto
               x 0.5 add pixy y sub 0.5 sub 0.5 inkspread sub 0 360 arc
            } if
        } for
        fill

        /pixs pixsorig def

    } bind def

    gsave

    % Draw the image
    /inkspread  inkspread  2 div def
    /inkspreadh inkspreadh 2 div def
    /inkspreadv inkspreadv 2 div def
    currentpoint translate
    width pixx div 72 mul height pixy div 72 mul scale
    0 0 moveto pixx 0 lineto pixx pixy lineto 0 pixy lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if

    colormap (unset) eq {
        /colormap << 1 barcolor >> def
    } if

    colormap {
        setanycolor
        /key exch def
        [
            pixs { key eq {1} {0} ifelse } forall
        ] dotty {drawlayerdots} {drawlayer} ifelse
    } forall

    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /fn () def
            txt {
                {} forall
                2 copy s ne exch fn ne or {
                    2 copy /s exch def /fn exch def
                    selectfont
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont textsize selectfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset x textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos x textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos x textxoffset add def } if
            textxalign (justify) eq textwidth x lt and {
                /textxpos 0 def
                /textgaps x textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset pixy add 1 add def } if
            textyalign (center) eq { /textypos textyoffset pixy textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if

    grestore

    end

}
[/barcode] {null def} forall
bind def
/renmatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp datamatrix 0.0 2020120900 208177 213373
%%BeginData:        917 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/datamatrix {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /format (square) def    % square or rectangle
    /version (unset) def
    /parse false def
    /parsefnc false def
    /encoding (auto) def
    /mailmark false def
    /raw false def
    /dmre false def      % Alias for isodmre
    /dindmre false def
    /isodmre false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    version (unset) ne {
        version (x) search
        pop /rows exch def
        pop /columns exch def
    } if

    /columns columns cvi def
    /rows rows cvi def

    /isodmre dmre def

    % Basic metrics for the each symbol
    %                         rows  cols  regh  regv  rscw  rsbl
    /metrics [
        % Standard square symbols
                             [  10    10     1     1     5     1 ]
                             [  12    12     1     1     7     1 ]
                             [  14    14     1     1    10     1 ]
                             [  16    16     1     1    12     1 ]
                             [  18    18     1     1    14     1 ]
                             [  20    20     1     1    18     1 ]
                             [  22    22     1     1    20     1 ]
                             [  24    24     1     1    24     1 ]
                             [  26    26     1     1    28     1 ]
                             [  32    32     2     2    36     1 ]
                             [  36    36     2     2    42     1 ]
                             [  40    40     2     2    48     1 ]
                             [  44    44     2     2    56     1 ]
                             [  48    48     2     2    68     1 ]
                             [  52    52     2     2    84     2 ]
                             [  64    64     4     4   112     2 ]
                             [  72    72     4     4   144     4 ]
                             [  80    80     4     4   192     4 ]
                             [  88    88     4     4   224     4 ]
                             [  96    96     4     4   272     4 ]
                             [ 104   104     4     4   336     6 ]
                             [ 120   120     6     6   408     6 ]
                             [ 132   132     6     6   496     8 ]
                             [ 144   144     6     6   620    10 ]
        % Optional rectangular symbols
                             [   8    18     1     1     7     1 ]
                             [   8    32     1     2    11     1 ]
        dindmre isodmre or { [   8    48     1     2    15     1 ] } if
        dindmre isodmre or { [   8    64     1     4    18     1 ] } if
                isodmre    { [   8    80     1     4    22     1 ] } if
                isodmre    { [   8    96     1     4    28     1 ] } if
                isodmre    { [   8   120     1     6    32     1 ] } if
                isodmre    { [   8   144     1     6    36     1 ] } if
                             [  12    26     1     1    14     1 ]
                             [  12    36     1     2    18     1 ]
        dindmre isodmre or { [  12    64     1     4    27     1 ] } if
                isodmre    { [  12    88     1     4    36     1 ] } if
                             [  16    36     1     2    24     1 ]
                             [  16    48     1     2    28     1 ]
        dindmre isodmre or { [  16    64     1     4    36     1 ] } if
                isodmre    { [  20    36     1     2    28     1 ] } if
                isodmre    { [  20    44     1     2    34     1 ] } if
                isodmre    { [  20    64     1     4    42     1 ] } if
                isodmre    { [  22    48     1     2    38     1 ] } if
        dindmre            { [  24    32     1     2    28     1 ] } if
        dindmre            { [  24    36     1     2    33     1 ] } if
        dindmre isodmre or { [  24    48     1     2    41     1 ] } if
        dindmre isodmre or { [  24    64     1     4    46     1 ] } if
        dindmre            { [  26    32     1     2    32     1 ] } if
        dindmre isodmre or { [  26    40     1     2    38     1 ] } if
        dindmre isodmre or { [  26    48     1     2    42     1 ] } if
        dindmre isodmre or { [  26    64     1     4    50     1 ] } if
    ] def

    % Create array of codewords remaining to make a full symbol
    /urows rows def
    /ucols columns def
    /fullcws [] def
    metrics {
        /m exch def
        /rows m 0 get def                          % Rows in symbol
        /cols m 1 get def                          % Columns in symbol
        /regh m 2 get def                          % Horizontal regions
        /regv m 3 get def                          % Vertical regions
        /rscw m 4 get def                          % Error correction codewords
        /rsbl m 5 get def                          % Error correction blocks
        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix
        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix
        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords
        /okay true def
        urows 0 ne urows rows ne and {/okay false def} if
        ucols 0 ne ucols cols ne and {/okay false def} if
        format (square) eq rows cols ne and {/okay false def} if
        format (rectangle) eq rows cols eq and {/okay false def} if
        okay {/fullcws [ fullcws aload pop ncws ] def} if
    } forall
    /numremcws [ 1558 {10000} repeat ] def
    fullcws {numremcws exch 1 sub 1 put} forall
    1556 -1 0 {
        /i exch def
        numremcws i get 1 ne {
            numremcws i numremcws i 1 add get 1 add put
        } if
    } for

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if  % encoding=raw

    encoding (auto) eq {

        % Special characters
        /fnc1  -1 def  /prog  -2 def  /m05   -3 def  /m06   -4 def
        /lC    -5 def  /lB    -6 def  /lX    -7 def  /lT    -8 def  /lE    -9 def  /unl -10 def
        /sapp -11 def  /usft -12 def  /sft1 -13 def  /sft2 -14 def  /sft3 -15 def  /eci -16 def  /pad -17 def
        /unlcw 254 def

        % Parse the input
        /fncvals <<
            /parse parse
            /parsefnc parsefnc
            /eci true
            (FNC1) fnc1
            (PROG) prog
%            (MAC5) m05    Encoded automatically
%            (MAC6) m06    Encoded automatically
        >> def
        /msg barcode fncvals //parseinput exec def
        /msglen msg length def

        % Macro 05/06 compression of [)>{RS}05/06{GS}...{RS}{EOT} structured data
        msglen 9 ge {
            msg 0 7 getinterval aload pop
            29 eq exch pop exch 48 eq and exch  % [)>{RS}0*{GS}...
            30 eq and exch 62 eq and exch 41 eq and exch 91 eq and {
                msg msglen 2 sub 2 getinterval aload pop
                4 eq exch 30 eq and {           %              ...{RS}{EOT}
                    msg 5 get 53 eq {           %      ...5...
                        /msg [ m05 msg 7 msg length 9 sub getinterval aload pop ] def
                    } if
                    msg 5 get 54 eq {           %      ...6...
                        /msg [ m06 msg 7 msg length 9 sub getinterval aload pop ] def
                    } if
                } if
            } if
        } if
        /msglen msg length def

        /Avals <<
            0 1 128 {dup 1 add} for
            pad 129
            0 1 99 {  % Double digits
                dup 10 2 string cvrs (00) 2 string copy dup 2 3 index length sub 4 -1 roll putinterval
                exch 130 add
            } for
            229 [ lC lB fnc1 sapp prog usft m05 m06 lX lT lE eci ] {exch 1 add dup} forall pop
        >> def
        /Avals <<
            Avals {[exch]} forall
        >> def

        /CNvals <<
            sft1 0
            sft2 1
            sft3 2
            32   3
            48 1 57 {dup 44 sub} for  % 0-9
            65 1 90 {dup 51 sub} for  % A-Z
        >> def
        /C1vals << 0 1 31 {dup} for >> def
        /C2vals <<
            33 1 47 {dup 33 sub} for
            58 1 64 {dup 43 sub} for
            91 1 95 {dup 69 sub} for
            fnc1 27
            usft 30
        >> def
        /C3vals << 96 1 127 {dup 96 sub} for >> def
        /Cvals <<
            CNvals {[exch]} forall
            C1vals {[exch CNvals sft1 get exch]} forall
            C2vals {[exch CNvals sft2 get exch]} forall
            C3vals {[exch CNvals sft3 get exch]} forall
        >> def

        /TNvals <<
            sft1 0
            sft2 1
            sft3 2
            32   3
            48 1  57 {dup 44 sub} for  % 0-9
            97 1 122 {dup 83 sub} for  % a-z
        >> def
        /T1vals << 0 1 31 {dup} for >> def
        /T2vals <<
            33 1 47 {dup 33 sub} for
            58 1 64 {dup 43 sub} for
            91 1 95 {dup 69 sub} for
            fnc1 27
            usft 30
        >> def
        /T3vals <<
             96 0
             65 1  90 {dup 64 sub} for
            123 1 127 {dup 96 sub} for
        >> def
        /Tvals <<
            TNvals {[exch]} forall
            T1vals {[exch TNvals sft1 get exch]} forall
            T2vals {[exch TNvals sft2 get exch]} forall
            T3vals {[exch TNvals sft3 get exch]} forall
        >> def

        % Extended ASCII mappings
        128 1 255 {
            /i exch def
            Avals i [ Avals usft get aload pop Avals i 128 sub get aload pop ] put
            Cvals i [ Cvals usft get aload pop Cvals i 128 sub get aload pop ] put
            Tvals i [ Tvals usft get aload pop Tvals i 128 sub get aload pop ] put
        } for

        /Xvals <<
            13 0
            42 1
            62 2
            32 3
            48 1 57 {dup 44 sub} for
            65 1 90 {dup 51 sub} for
        >> def
        /Xvals <<
            Xvals {[exch]} forall
        >> def

        /Evals <<
            64 1 94 {dup 64 sub} for
            unl 31
            32 1 63 {dup} for
        >> def
        /Evals <<
            Evals {[exch]} forall
        >> def

        /Bvals <<
            0 1 255 {dup} for
        >> def
        /Bvals <<
            Bvals {[exch]} forall
        >> def

        /encvals [ Avals Cvals Tvals Xvals Evals Bvals ] def

        /numD      [ msglen {0} repeat 0 ] def
        /nextXterm [ msglen {0} repeat 9999 ] def
        /nextNonX  [ msglen {0} repeat 9999 ] def
        /isECI     [ msglen {false} repeat false ] def
        msglen 1 sub -1 0 {
            /i exch def
            /barchar msg i get def
            barchar 48 ge barchar 57 le and {
                numD i numD i 1 add get 1 add put
            } if
            barchar 13 eq barchar 42 eq or barchar 62 eq or {
                nextXterm i 0 put
            } {
                nextXterm i nextXterm i 1 add get 1 add put
            } ifelse
            Xvals barchar known not {
                nextNonX i 0 put
            } {
                nextNonX i nextNonX i 1 add get 1 add put
            } ifelse
            isECI i barchar -1000000 le put
        } for
        /nextXterm [nextXterm {dup 10000 gt {pop 10000} if} forall] def
        /nextNonX  [nextNonX  {dup 10000 gt {pop 10000} if} forall] def

        /isD  {char 48 ge char 57 le and} bind def
        /isC  {CNvals char known} bind def
        /isT  {TNvals char known} bind def
        /isX  {Xvals char known} bind def
        /isE  {Evals char known} bind def
        /isEA {char 127 gt} bind def
        /isFN {char 0 lt} bind def
        /XtermFirst {dup nextXterm exch get exch nextNonX exch get lt} bind def

        /A 0 def  /C 1 def  /T 2 def  /X 3 def  /E 4 def  /B 5 def

        /lookup {
            /ac 1 def /cc 2 def /tc 2 def /xc 2 def /ec 2 def /bc 2.25 def
            mode A eq {/ac 0 def /cc 1 def /tc 1 def /xc 1 def /ec 1 def /bc 1.25 def} if
            mode C eq {/cc 0 def} if
            mode T eq {/tc 0 def} if
            mode X eq {/xc 0 def} if
            mode E eq {/ec 0 def} if
            mode B eq {/bc 0 def} if
            1 {  % common exit
                isECI i get {A exit} if  % ECI only in ASCII
                mailmark i 45 lt and {C exit} if  % Mailmark is C40 only for 45 characters
                /k 0 def {  % loop
                    i k add msglen eq {
                        [/ac /cc /tc /xc /ec /bc] {dup load ceiling def} forall
                        true [   cc tc xc ec bc] {ac exch le and} forall {A exit} if
                        true [ac cc tc xc ec   ] {bc exch lt and} forall {B exit} if
                        true [ac cc tc xc    bc] {ec exch lt and} forall {E exit} if
                        true [ac cc    xc ec bc] {tc exch lt and} forall {T exit} if
                        true [ac cc tc    ec bc] {xc exch lt and} forall {X exit} if
                        C exit
                    } if
                    /char msg i k add get def
                    /ac ac isD {1 2 div add} {isEA {ceiling 2 add} {ceiling 1 add} ifelse} ifelse def
                    /cc cc isC {2 3 div add} {isEA { 8 3 div add } { 4 3 div add } ifelse} ifelse def
                    /tc tc isT {2 3 div add} {isEA { 8 3 div add } { 4 3 div add } ifelse} ifelse def
                    /xc xc isX {2 3 div add} {isEA {13 3 div add } {10 3 div add } ifelse} ifelse def
                    /ec ec isE {3 4 div add} {isEA {17 4 div add } {13 4 div add } ifelse} ifelse def
                    /bc bc isFN {4 add} {1 add} ifelse def
                    k 4 ge {
                        true [   cc tc xc ec bc] {ac 1 add exch le and} forall {A exit} if
                        bc 1 add ac le {B exit} if
                        true [   cc tc xc ec   ] {bc 1 add exch lt and} forall {B exit} if
                        true [ac cc tc xc    bc] {ec 1 add exch lt and} forall {E exit} if
                        true [ac cc    xc ec bc] {tc 1 add exch lt and} forall {T exit} if
                        true [ac cc tc    ec bc] {xc 1 add exch lt and} forall {X exit} if
                        true [ac    tc    ec bc] {cc 1 add exch lt and} forall {
                            cc xc lt {C exit} if
                            cc xc eq {i k add 1 add XtermFirst {X exit} {C exit} ifelse} if
                        } if
                    } if
                    /k k 1 add def
                } loop
            } repeat
        } bind def

        /addtocws {
            dup cws exch j exch putinterval
            /j exch length j add def
        } bind def

        /ECItocws {
            neg 1000000 sub
                dup 000126 le {  % ECI 000000 - 000126
                1 add
                1 array astore
            } { dup 016382 le {  % ECI 000127 - 016382
                127 sub
                dup 254 idiv 128 add exch
                    254 mod 1 add
                2 array astore
            } {                  % ECI 016383 - 999999
                16383 sub
                dup 64516 idiv         192 add exch
                dup   254 idiv 254 mod   1 add exch
                               254 mod   1 add
                3 array astore
            } ifelse } ifelse
        } bind def

        /encA {
            1 {  % Common exit
                isECI i get {
                    Avals eci get addtocws
                    msg i get ECItocws addtocws
                    /i i 1 add def
                    exit
                } if
                numD i get 2 ge {
                    2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws
                    /i i 2 add def
                    exit
                } if
                /newmode lookup def
                newmode mode ne {
                    Avals [-1 lC lT lX lE lB] newmode get get addtocws
                    /mode newmode def
                    exit
                } if
                Avals msg i get get addtocws
                /i i 1 add def
                exit
            } repeat
        } bind def

        /CTXvalstocws {
            /in exch def
            mark
            0 3 in length 1 sub {
                in exch 3 getinterval 0 exch {add 40 mul} forall 40 idiv 1 add
                dup 256 idiv exch 256 mod
            } for
            counttomark array astore exch pop
        } bind def

        /encCTX {
            /p 0 def
            /ctxvals 2500 array def
            /done false def

            % Lookup the values for each character
            {
                i msglen eq {exit} if
                encvals mode get msg i get known not {exit} if
                p 3 mod 0 eq {
                    /newmode lookup def
                    newmode mode ne {
                        ctxvals 0 p getinterval CTXvalstocws addtocws
                        [unlcw] addtocws
                        newmode A ne {
                            Avals [-1 lC lT lX lE lB] newmode get get addtocws
                        } if
                        /mode newmode def
                        /done true def
                        exit
                    } if
                    msglen i sub 3 le {  % Check end of data conditions
                        /remcws numremcws j p 3 idiv 2 mul add get def
                        /remvals [
                            msg i msglen i sub getinterval {
                                dup encvals mode get exch known {
                                    encvals mode get exch get aload pop
                                } {  % Unencodable X12 characters
                                    pop -1 -1 -1 -1
                                } ifelse
                            } forall
                        ] def
                        remcws 2 eq remvals length 3 eq and {
                            % Encode and omit unlatch
                            [
                                ctxvals 0 p getinterval aload pop
                                remvals aload pop
                            ] CTXvalstocws addtocws
                            /mode A def
                            /i msglen def
                            /done true def
                            exit
                        } if
                        remcws 2 eq remvals length 2 eq and mode X ne and {
                            % Encode with sft1 as third value, omit unlatch
                            [
                                ctxvals 0 p getinterval aload pop
                                remvals aload pop
                                encvals mode get sft1 get aload pop
                            ] CTXvalstocws addtocws
                            /mode A def
                            /i msglen def
                            /done true def
                            exit
                        } if
                        remcws 2 eq remvals length 1 eq and {
                            % Unlatch to ASCII
                            ctxvals 0 p getinterval CTXvalstocws addtocws
                            [unlcw] addtocws
                            Avals msg i get get addtocws
                            /mode A def
                            /i msglen def
                            /done true def
                            exit
                        } if
                        remcws 1 eq remvals length 1 eq and {
                            % Implied unlatch to ASCII
                            ctxvals 0 p getinterval CTXvalstocws addtocws
                            Avals msg i get get addtocws
                            /mode A def
                            /i msglen def
                            /done true def
                            exit
                        } if
                    } if
                } if
                encvals mode get msg i get get
                dup ctxvals exch p exch putinterval
                /p exch length p add def
                /i i 1 add def
            } loop

            % Backtrack to a boundary and return to ASCII
            done not {
                {
                    p 3 mod 0 eq {exit} if
                    /i i 1 sub def
                    /p p encvals mode get msg i get get length sub def
                } loop
                [
                    ctxvals 0 p getinterval aload pop
                ] CTXvalstocws addtocws
                [unlcw] addtocws
                /mode A def
                % Encode something to avoid latching immediately back
                i msglen ne isECI i get not and {
                    numD i get 2 ge {
                        2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws
                        /i i 2 add def
                    } {
                        Avals msg i get get addtocws
                        /i i 1 add def
                    } ifelse
                } if
            } if

        } bind def

        /Evalstocws {
            /in exch def
            /inlen in length def
            /outlen in length 4 div 3 mul ceiling cvi def
            /in [ in aload pop 0 0 0 ] def
            mark
            0 4 inlen 1 sub {
                in exch 4 getinterval 0 exch {or 6 bitshift} forall -6 bitshift
                dup -16 bitshift 255 and exch
                dup -8 bitshift 255 and exch
                255 and
            } for
            counttomark array astore exch pop
            0 outlen getinterval
        } bind def

        /encE {
            /p 0 def
            /edifactvals 2100 array def

            % Lookup the values for each character
            {
                i msglen eq {exit} if
                Evals msg i get known not {exit} if
                p 4 mod 0 eq {
                    msglen i sub 2 le {  % Check end of data condition
                        /remcws numremcws j p 4 idiv 3 mul add get def
                        /remvals [
                            msg i msglen i sub getinterval {
                                Avals exch get aload pop
                            } forall
                        ] def
                        remcws 1 eq remcws 2 eq or remvals length remcws le and {
                            % Implied unlatch to ASCII
                            edifactvals 0 p getinterval Evalstocws addtocws
                            remvals addtocws
                            /mode A def
                            /i msglen def
                            exit
                        } if
                    } if
                    lookup mode ne {exit} if
                } if
                Evals msg i get get
                dup edifactvals exch p exch putinterval
                /p exch length p add def
                /i i 1 add def
            } loop

            % Unlatch and pad with zeros until boundary
            mode A ne {
                /remcws numremcws j p 4 idiv 3 mul add 1 sub get 1 sub def
                p 4 mod 0 ne i msglen ne or remcws 3 ge or {  % Unlatch unless less than 3 codewords remain
                    Evals unl get
                    dup edifactvals exch p exch putinterval
                    /p exch length p add def
                } if
                edifactvals 0 p getinterval Evalstocws addtocws
                /mode A def
                % Encode something to avoid latching immediately back
                i msglen ne isECI i get not and {
                    numD i get 2 ge {
                        2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws
                        /i i 2 add def
                    } {
                        Avals msg i get get addtocws
                        /i i 1 add def
                    } ifelse
                } if
            } if

        } bind def

        /encB {
            /p 0 def /bvals 1558 array def {
                i msglen eq {exit} if
                lookup mode ne {exit} if
                bvals p msg i get put
                /p p 1 add def
                /i i 1 add def
            } loop
            /remcws numremcws j p add get 1 sub def
            /bvals [
                remcws 0 eq i msglen eq and {  % Terminates symbol
                    0
                } {
                    p 250 lt {p} {p 250 idiv 249 add p 250 mod} ifelse
                } ifelse
                bvals 0 p getinterval aload pop
            ] def
            0 1 bvals length 1 sub {  % Pseudo-randomise based on codeword position
                /p exch def
                j p add 1 add 149 mul 255 mod 1 add bvals p get add
                dup 256 ge {256 sub} if
                bvals exch p exch put
            } for
            bvals addtocws
            /mode A def
        } bind def

        % Derive the codewords
        /cws 1558 array def
        /mode A def /i 0 def /j 0 def {
            i msglen ge {exit} if
            [ /encA /encCTX /encCTX /encCTX /encE /encB ] mode get load exec
        } loop
        /cws cws 0 j getinterval def

    } if  % encoding=auto

    % Extend codewords to fill symbol with pseudo-randomised pad characters
    /datlen cws length def
    /remcws numremcws j 1 sub get 1 sub def
    remcws 0 gt {
        /cws [ cws aload pop remcws {129} repeat ] def
        datlen 1 add 1 datlen remcws add 1 sub {
            /i exch def
            i 1 add 149 mul 253 mod 1 add 129 add
            dup 254 gt {254 sub} if
            cws exch i exch put
        } for
    } if

    % Lookup symbol metrics based on number of codewords and user specification
    /i 0 def { % loop
        /m metrics i get def
        /rows m 0 get def                          % Rows in symbol
        /cols m 1 get def                          % Columns in symbol
        /regh m 2 get def                          % Horizontal regions
        /regv m 3 get def                          % Vertical regions
        /rscw m 4 get def                          % Error correction codewords
        /rsbl m 5 get def                          % Error correction blocks
        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix
        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix
        /rrows mrows regh idiv def                 % Rows per region
        /rcols mcols regv idiv def                 % Columns per region
        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords
        /okay true def
        cws length ncws ne           {/okay false def} if
        urows 0 ne urows rows ne and {/okay false def} if
        ucols 0 ne ucols cols ne and {/okay false def} if
        format (square) eq rows cols ne and {/okay false def} if
        format (rectangle) eq rows cols eq and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        cws length 1558 ne {
            /cwbsize cws length rsbl idiv def
        } {
            i 7 le {/cwbsize 156 def} {/cwbsize 155 def} ifelse
        } ifelse
        /cwb cwbsize array def
        0 1 cwbsize 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for
        cwbs i cwb put
        ecbs i [ rscw rsbl idiv {0} repeat ] put
    } for

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {301 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 rscw rsbl idiv {0} repeat ] def
    1 1 rscw rsbl idiv {
        /i exch def
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Calculate the error correction codewords for each block
    0 1 cwbs length 1 sub {
        /i exch def
        /cwb cwbs i get def
        /ecb ecbs i get def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def
            ecb length 1 sub -1 0 {
                /j exch def
                /p ecb length j sub 1 sub def
                ecb p t coeffs j get rsprod put
                j 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for
        } for
    } for

    % Strange fixup for 144x144 symbols
    ncws 1558 eq {
        /ecbs [ ecbs 8 2 getinterval {} forall ecbs 0 8 getinterval {} forall ] def
    } if

    % Extend codewords with the interleaved error correction codes
    /cws [ cws {} forall rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws ncws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Place the codewords into the matrix
    /module {
        % cw row col shape
        4 -1 roll
        (00000000) 8 string copy dup 3 -1 roll 2 8 string cvrs
        dup length 8 exch sub exch putinterval
        7 -1 0 {1 index exch get 48 sub exch} for pop
        11 -3 roll
        % 1 2 4 8 16 32 64 128 row col shape
        {  % Place each bit of the codeword in the shape, MSB first
            exec
            1 index 0 lt {
                exch mrows add exch
                4 mrows 4 add 8 mod sub add
            } if
            dup 0 lt {
                mcols add exch
                4 mcols 4 add 8 mod sub add exch
            } if
            1 index mrows ge {
                exch mrows sub exch
            } if
            exch mcols mul add
            mmat exch 5 -1 roll put
        } forall
    } bind def

    % Placement patterns
    /dmn [
        { 2 copy 2 sub exch 2 sub exch } bind  { 2 copy 1 sub exch 2 sub exch } bind
        { 2 copy 2 sub exch 1 sub exch } bind  { 2 copy 1 sub exch 1 sub exch } bind
        { 2 copy exch 1 sub exch } bind        { 2 copy 2 sub } bind
        { 2 copy 1 sub } bind                  { 2 copy } bind
    ] def

    /dmc1 [
        { mrows 1 sub 0 } bind  { mrows 1 sub 1 } bind
        { mrows 1 sub 2 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def

    /dmc2 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 4 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
    ] def

    /dmc3 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def

    /dmc4 [
        { mrows 1 sub 0 } bind  { mrows 1 sub mcols 1 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 3 sub } bind
        { 1 mcols 2 sub } bind  { 1 mcols 1 sub } bind
    ] def

    /mmat [ mrows mcols mul {-1} repeat ] def
    cws length 1 sub -1 0 {cws exch get} for  % Reverse cws onto stack
    4 0  % Starting row and column
    { % loop
        2 copy 0 eq exch mrows eq and {
            dmc1 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 4 mod 0 ne and {
            dmc2 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 8 mod 4 eq and {
            dmc3 module
        } if
        2 copy 2 eq exch mrows 4 add eq and mcols 8 mod 0 eq and {
            dmc4 module
        } if

        { % loop for sweeping upwards
            2 copy 0 ge exch mrows lt and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 add exch 2 sub exch
            2 copy mcols lt exch 0 ge and not {exit} if
        } loop
        3 add exch 1 add exch

        { % loop for sweeping downwards
            2 copy mcols lt exch 0 ge and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 sub exch 2 add exch
            2 copy 0 ge exch mrows lt and not {exit} if
        } loop
        1 add exch 3 add exch

        2 copy mcols lt exch mrows lt or not {pop pop exit} if

    } loop

    % Set checker pattern if required
    mmat mrows mcols mul 1 sub get -1 eq {
        mmat mrows mcols 1 sub mul 2 sub [1 0] putinterval
        mmat mrows mcols mul 2 sub [0 1] putinterval
    } if

    % Place the modules onto a pixel map between alignment patterns
    /pixs rows cols mul array def
    /cwpos 0 def
    0 1 rows 1 sub {
        /i exch def
        i rrows 2 add mod 0 eq { pixs i cols mul [ cols 2 idiv {1 0} repeat ] putinterval } if
        i rrows 2 add mod rrows 1 add eq { pixs i cols mul [ cols {1} repeat ] putinterval } if
        i rrows 2 add mod 0 ne i rrows 2 add mod rrows 1 add ne and {
            0 1 cols 1 sub {
                /j exch def
                j rcols 2 add mod 0 eq { pixs i cols mul j add 1 put } if
                j rcols 2 add mod rcols 1 add eq { pixs i cols mul j add i 2 mod put } if
                j rcols 2 add mod 0 ne j rcols 2 add mod rcols 1 add ne and {
                    pixs i cols mul j add mmat cwpos get put
                    /cwpos cwpos 1 add def
                } if
            } for
        } if
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 2 mul 72 div
    /width cols 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

}
[/barcode] {null def} forall
bind def
/datamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource

%%BeginResource: uk.co.terryburton.bwipp gs1datamatrix 0.0 2020120900 68789 72228
%%BeginData:        130 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /gs1lint dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /datamatrix dup /uk.co.terryburton.bwipp findresource put
begin
/gs1datamatrix {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /dontlint false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /fncvals <<
            /parse parse
            /parseonly true
            /parsefnc false
        >> def
        fncvals //parseinput exec
    } bind def

    % Parse out AIs
    /ais  [] def
    /vals [] def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll
        } {
            () 3 1 roll
        } ifelse
        [ ais  aload pop counttomark 2 add index ] /ais exch def
        [ vals aload pop counttomark 1 add index expand ] /vals exch def
        pop pop
    } loop
    pop
    dontlint not {ais vals //gs1lint exec} if

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Create the datamatrix data
    /fnc1 -1 def
    /dmtx [ fnc1 ] def
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val vals i get def
        dmtx length ai length add val length add array
        dup 0 dmtx putinterval
        dup dmtx length ai [ exch {} forall ] putinterval
        dup dmtx length ai length add val [ exch {} forall ] putinterval
        /dmtx exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            dmtx length 1 add array
            dup 0 dmtx putinterval
            dup dmtx length fnc1 put
            /dmtx exch def
        } if
    } for

    % Compose input to datamatrix
    /barcode dmtx length 1 add 5 mul string def
    /i 0 def /j 0 def {
        i dmtx length eq {exit} if
        dmtx i get dup fnc1 eq {
            pop barcode j (^FNC1) putinterval
            /j j 4 add def
        } {
            barcode exch j exch put
        } ifelse
        /i i 1 add def
        /j j 1 add def
    } loop
    /barcode barcode 0 j getinterval def

    % Get the result of encoding with datamatrix
    options (parse) undef
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //datamatrix exec def

    args (opt) options put
    args

    dontdraw not //renmatrix if

    end

}
[/barcode] {null def} forall
bind def
/gs1datamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource


2 dup scale

10 10 moveto
((00)006141411234567890(10)ABC123)
()
/gs1datamatrix /uk.co.terryburton.bwipp findresource exec

showpage

